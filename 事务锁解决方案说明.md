# 数据库与通知之间的事务锁解决方案

## 问题描述

在原有实现中，通知服务使用了 `@Transactional(propagation = REQUIRES_NEW)`，这会导致以下问题：

1. **事务锁问题**：在主事务未提交时开启新事务，可能导致死锁
2. **性能问题**：通知发送是耗时操作，阻塞主事务提交
3. **数据一致性风险**：如果主事务回滚，通知已发送无法撤回

## 解决方案架构

采用 **事务事件监听器 + 异步处理** 的方案：

```
业务事务 → 发布事件 → 事务提交 → 监听器捕获 → 异步发送通知
```

### 核心组件

#### 1. 异步配置 (AsyncConfig.java)

```java
@Configuration
@EnableAsync
public class AsyncConfig {
    @Bean("notificationExecutor")
    public Executor notificationExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);        // 核心线程数
        executor.setMaxPoolSize(10);        // 最大线程数
        executor.setQueueCapacity(100);     // 队列容量
        executor.setThreadNamePrefix("notification-");
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        executor.initialize();
        return executor;
    }
}
```

#### 2. 异步通知服务 (AsyncNotificationService.java)

```java
@Service
public class AsyncNotificationService {

    @Resource
    private INotificationService notificationService;

    /**
     * 事务提交后异步发送通知
     * - @Async: 异步执行
     * - @TransactionalEventListener: 监听事务事件
     * - phase = AFTER_COMMIT: 在事务提交后执行
     */
    @Async("notificationExecutor")
    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    public void handleNotificationEvent(NotificationSendDTO sendDTO) {
        try {
            notificationService.sendNotification(sendDTO);
        } catch (Exception e) {
            log.error("异步发送通知失败", e);
        }
    }
}
```

#### 3. 事件发布工具 (NotificationEventPublisher.java)

```java
@Component
public class NotificationEventPublisher {

    @Resource
    private ApplicationEventPublisher eventPublisher;

    /**
     * 发布通知事件（事务提交后异步执行）
     */
    public void publishNotification(NotificationSendDTO sendDTO) {
        eventPublisher.publishEvent(sendDTO);
    }
}
```

#### 4. 业务服务调用方式

**修改前（有事务锁问题）：**
```java
@Transactional
public void createBooking() {
    // 业务逻辑
    booking.save();

    // 直接调用，会在主事务中开启新事务
    notificationService.sendNotification(dto);  // ❌ 问题
}
```

**修改后（无事务锁问题）：**
```java
@Transactional
public void createBooking() {
    // 业务逻辑
    booking.save();

    // 发布事件，事务提交后异步执行
    notificationEventPublisher.publishNotification(dto);  // ✅ 正确
}
```

## 技术优势

### 1. 解决事务锁问题
- ✅ 通知在主事务提交后执行，避免事务嵌套
- ✅ 不会产生死锁或长时间持有锁

### 2. 提升性能
- ✅ 异步执行，不阻塞主事务
- ✅ 使用线程池，资源可控
- ✅ 主事务快速提交，提升吞吐量

### 3. 保证数据一致性
- ✅ 只有主事务成功提交才发送通知
- ✅ 主事务回滚时不会发送通知
- ✅ 通知失败不影响主业务

### 4. 可扩展性
- ✅ 易于添加其他事务后处理逻辑
- ✅ 支持多种事务阶段监听
- ✅ 线程池配置灵活可调

## 事务事件监听阶段

Spring 提供了4个事务阶段：

| 阶段 | 说明 | 使用场景 |
|------|------|----------|
| `BEFORE_COMMIT` | 事务提交前 | 数据校验、审计日志 |
| `AFTER_COMMIT` | 事务提交后 | **通知发送**、缓存更新 |
| `AFTER_ROLLBACK` | 事务回滚后 | 清理资源、记录失败 |
| `AFTER_COMPLETION` | 事务完成后（无论成功失败） | 资源释放 |

## 已修改的服务

### 1. BookingServiceImpl
- ✅ 预订成功通知
- ✅ 预订取消通知

### 2. CourseEnrollmentServiceImpl（待修改）
- ⏳ 课程报名成功通知
- ⏳ 课程报名取消通知

### 3. PaymentServiceImpl（待修改）
- ⏳ 支付成功通知
- ⏳ 退款成功通知

## 使用指南

### 步骤1：注入事件发布器

```java
@Service
public class YourService {
    @Resource
    private NotificationEventPublisher notificationEventPublisher;
}
```

### 步骤2：构建通知DTO

```java
NotificationSendDTO dto = new NotificationSendDTO();
dto.setUserId(userId);
dto.setTemplateCode("BOOKING_SUCCESS");
dto.setBizId(String.valueOf(bookingId));
dto.setBizType("booking");
dto.setNotificationType("system");

Map<String, Object> params = new HashMap<>();
params.put("bookingNo", bookingNo);
params.put("venueName", venueName);
dto.setParams(params);
```

### 步骤3：发布事件

```java
@Transactional
public void yourBusinessMethod() {
    // 业务逻辑
    // ...

    // 发布通知事件（事务提交后异步执行）
    notificationEventPublisher.publishNotification(dto);
}
```

## 监控和调试

### 日志输出

```
# 事件发布
[main] DEBUG NotificationEventPublisher - 发布通知事件: userId=1, templateCode=BOOKING_SUCCESS

# 异步执行
[notification-1] INFO AsyncNotificationService - 异步发送通知: userId=1, templateCode=BOOKING_SUCCESS

# 通知发送
[notification-1] INFO NotificationServiceImpl - 发送通知: userId=1, templateCode=BOOKING_SUCCESS
```

### 线程池监控

可以通过以下方式监控线程池状态：

```java
@Resource
@Qualifier("notificationExecutor")
private ThreadPoolTaskExecutor notificationExecutor;

public void monitorThreadPool() {
    log.info("活跃线程数: {}", notificationExecutor.getActiveCount());
    log.info("队列大小: {}", notificationExecutor.getThreadPoolExecutor().getQueue().size());
    log.info("已完成任务数: {}", notificationExecutor.getThreadPoolExecutor().getCompletedTaskCount());
}
```

## 注意事项

### 1. 异常处理
- 通知发送失败不会影响主业务
- 异常会被记录到日志中
- 可以考虑添加重试机制

### 2. 事务传播
- 移除了 `REQUIRES_NEW` 传播级别
- 使用默认的 `REQUIRED` 传播级别
- 避免事务嵌套问题

### 3. 性能调优
- 根据实际负载调整线程池参数
- 监控队列积压情况
- 必要时增加线程数或队列容量

### 4. 测试建议
- 测试主事务回滚时通知不发送
- 测试主事务成功时通知正常发送
- 测试高并发场景下的性能表现

## 总结

通过 **事务事件监听器 + 异步处理** 的方案，我们成功解决了：

1. ✅ 事务锁和死锁问题
2. ✅ 性能瓶颈问题
3. ✅ 数据一致性问题
4. ✅ 代码耦合问题

这是一个生产级的解决方案，符合Spring最佳实践。
