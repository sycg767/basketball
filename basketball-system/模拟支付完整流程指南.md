# 模拟支付完整流程指南

## 📖 概述

本系统实现了**完整的模拟在线支付流程**，可以模拟微信支付和支付宝支付的全流程，包括：
- ✅ 选择支付方式（微信/支付宝）
- ✅ 生成模拟二维码
- ✅ 展示二维码给用户
- ✅ 模拟扫码支付成功
- ✅ 轮询查询支付状态
- ✅ 自动更新订单状态

**适用场景**：开发、测试、演示环境，无需真实支付配置。

---

## 🎯 完整流程

### 流程图

```
用户创建预订订单
    ↓
选择"在线支付"
    ↓
选择具体方式（微信扫码/支付宝扫码）
    ↓
后端创建支付订单
    ↓
生成模拟二维码URL
    ↓
前端展示二维码
    ↓
前端开始轮询支付状态
    ↓
【模拟扫码】调用模拟支付接口
    ↓
后端处理支付回调
    ↓
更新支付订单状态 → 支付成功
    ↓
更新预订订单状态 → 已支付
    ↓
前端轮询检测到支付成功
    ↓
跳转到支付成功页面
```

---

## 🔧 API 接口详细说明

### 1. 创建预订订单

**接口**: `POST /api/booking`

**请求示例**:
```json
{
  "venueId": 1,
  "bookingDate": "2025-10-26",
  "startTime": "10:00",
  "endTime": "12:00",
  "contactName": "张三",
  "contactPhone": "13800138000",
  "peopleCount": 5
}
```

**响应示例**:
```json
{
  "code": 200,
  "message": "操作成功",
  "data": 13
}
```

📝 **记录 bookingId**: 13

---

### 2. 发起支付

**接口**: `PUT /api/booking/{bookingId}/pay`

**请求示例**:
```json
{
  "paymentMethod": 1,
  "paymentType": "wechat_native"
}
```

**参数说明**:
| 参数 | 类型 | 必填 | 说明 |
|-----|------|------|------|
| `paymentMethod` | `Integer` | 是 | 1-在线支付, 2-余额, 3-会员卡, 4-现场支付 |
| `paymentType` | `String` | 条件必填 | 当 paymentMethod=1 时必填<br>`wechat_native` - 微信扫码<br>`alipay_page` - 支付宝扫码 |

**响应示例**:
```json
{
  "code": 200,
  "message": "操作成功",
  "data": {
    "paymentNo": "PAY1760739882345",
    "businessNo": "BK1760739804199",
    "businessType": "booking",
    "paymentType": "wechat_native",
    "amount": 300.00,
    "actualAmount": 300.00,
    "status": 0,
    "qrCodeUrl": "https://api.mch.weixin.qq.com/pay/qrcode?data=mock_PAY1760739882345",
    "expireTime": "2025-10-18 07:32:45"
  }
}
```

📝 **记录关键信息**:
- `paymentNo`: PAY1760739882345（支付订单号）
- `qrCodeUrl`: 模拟二维码URL
- `status`: 0（待支付）

---

### 3. 展示二维码

**前端处理**:
1. 将 `qrCodeUrl` 转换为二维码图片展示给用户
2. 可以使用 QRCode.js 或其他二维码库生成
3. 同时显示支付倒计时（30分钟过期）

**前端代码示例**:
```html
<template>
  <div class="payment-modal">
    <h3>{{ paymentType === 'wechat_native' ? '微信支付' : '支付宝支付' }}</h3>
    
    <!-- 二维码 -->
    <div id="qrcode"></div>
    <p>请使用{{ paymentType === 'wechat_native' ? '微信' : '支付宝' }}扫码支付</p>
    
    <!-- 金额 -->
    <p class="amount">¥{{ amount }}</p>
    
    <!-- 倒计时 -->
    <p class="countdown">{{ countdown }}后订单将关闭</p>
    
    <!-- 测试环境提示 -->
    <div class="test-hint">
      <p>测试环境：请使用模拟支付功能</p>
      <button @click="mockScanSuccess">模拟扫码成功</button>
    </div>
  </div>
</template>

<script>
import QRCode from 'qrcodejs2';

export default {
  data() {
    return {
      paymentNo: '',
      qrCodeUrl: '',
      amount: 0,
      paymentType: '',
      countdown: '30:00',
      timer: null
    };
  },
  
  mounted() {
    // 生成二维码
    new QRCode(document.getElementById('qrcode'), {
      text: this.qrCodeUrl,
      width: 200,
      height: 200
    });
    
    // 开始轮询支付状态
    this.startPolling();
    
    // 开始倒计时
    this.startCountdown();
  },
  
  methods: {
    // 轮询查询支付状态
    startPolling() {
      this.timer = setInterval(async () => {
        const response = await this.$http.get(`/api/payment/query/${this.paymentNo}`);
        
        if (response.data.code === 200) {
          const status = response.data.data.status;
          
          if (status === 2) {
            // 支付成功
            clearInterval(this.timer);
            this.$message.success('支付成功！');
            this.$router.push('/booking/success');
          } else if (status === 3) {
            // 支付失败
            clearInterval(this.timer);
            this.$message.error('支付失败，请重试');
          }
        }
      }, 2000); // 每2秒查询一次
    },
    
    // 模拟扫码成功（仅测试环境）
    async mockScanSuccess() {
      try {
        const response = await this.$http.post(`/api/mock/payment/scan-success/${this.paymentNo}`);
        if (response.data.code === 200) {
          this.$message.success('模拟支付成功，请等待状态更新...');
        }
      } catch (error) {
        this.$message.error('模拟支付失败：' + error.message);
      }
    },
    
    // 倒计时
    startCountdown() {
      let seconds = 30 * 60; // 30分钟
      const countdownTimer = setInterval(() => {
        const minutes = Math.floor(seconds / 60);
        const secs = seconds % 60;
        this.countdown = `${minutes}:${secs.toString().padStart(2, '0')}`;
        
        seconds--;
        if (seconds < 0) {
          clearInterval(countdownTimer);
          clearInterval(this.timer);
          this.$message.warning('订单已超时，请重新下单');
        }
      }, 1000);
    }
  },
  
  beforeDestroy() {
    if (this.timer) {
      clearInterval(this.timer);
    }
  }
};
</script>
```

---

### 4. 轮询查询支付状态

**接口**: `GET /api/payment/query/{paymentNo}`

**请求示例**:
```
GET /api/payment/query/PAY1760739882345
```

**响应示例（待支付）**:
```json
{
  "code": 200,
  "data": {
    "paymentNo": "PAY1760739882345",
    "status": 0,
    "qrCodeUrl": "https://api.mch.weixin.qq.com/pay/qrcode?data=mock_PAY1760739882345"
  }
}
```

**响应示例（支付成功）**:
```json
{
  "code": 200,
  "data": {
    "paymentNo": "PAY1760739882345",
    "status": 2,
    "paidTime": "2025-10-18 06:35:00",
    "thirdPartyTradeNo": "MOCK_1729221300000"
  }
}
```

**状态码说明**:
| status | 说明 |
|--------|------|
| 0 | 待支付 - 继续轮询 |
| 1 | 支付中 - 继续轮询 |
| 2 | 支付成功 - 停止轮询，跳转成功页 |
| 3 | 支付失败 - 停止轮询，提示用户 |
| 4 | 已取消 - 停止轮询 |
| 5 | 已退款 - 停止轮询 |

---

### 5. 模拟扫码支付（测试环境专用）

**接口**: `POST /api/mock/payment/scan-success/{paymentNo}`

**请求示例**:
```
POST /api/mock/payment/scan-success/PAY1760739882345
```

**响应示例**:
```json
{
  "code": 200,
  "message": "操作成功",
  "data": "SUCCESS"
}
```

**⚠️ 注意**:
- 此接口**仅用于测试环境**
- 模拟用户扫码并支付成功的行为
- 调用后会立即触发支付回调流程
- 更新支付订单状态为"支付成功"
- 更新预订订单状态为"已支付"

---

## 💻 完整测试流程

### 使用 Postman 测试

#### Step 1: 创建预订订单
```bash
POST http://localhost:8080/api/booking
Authorization: Bearer {your_jwt_token}

{
  "venueId": 1,
  "bookingDate": "2025-10-26",
  "startTime": "10:00",
  "endTime": "12:00",
  "contactName": "测试用户",
  "contactPhone": "13800138000",
  "peopleCount": 5
}
```

#### Step 2: 发起支付（微信扫码）
```bash
PUT http://localhost:8080/api/booking/13/pay
Authorization: Bearer {your_jwt_token}

{
  "paymentMethod": 1,
  "paymentType": "wechat_native"
}
```

**或者发起支付（支付宝扫码）**
```bash
{
  "paymentMethod": 1,
  "paymentType": "alipay_page"
}
```

#### Step 3: 查询支付状态
```bash
GET http://localhost:8080/api/payment/query/PAY1760739882345
Authorization: Bearer {your_jwt_token}
```

#### Step 4: 模拟扫码成功
```bash
POST http://localhost:8080/api/mock/payment/scan-success/PAY1760739882345
Authorization: Bearer {your_jwt_token}
```

#### Step 5: 再次查询支付状态（验证成功）
```bash
GET http://localhost:8080/api/payment/query/PAY1760739882345
# status 应该变为 2（支付成功）
```

#### Step 6: 查询预订订单状态
```bash
GET http://localhost:8080/api/booking/13
# status 应该变为 1（已支付）
```

---

## 🎨 前端集成建议

### Vue.js 示例

```javascript
// 支付流程封装
class PaymentFlow {
  constructor(bookingId, amount) {
    this.bookingId = bookingId;
    this.amount = amount;
    this.paymentNo = null;
    this.pollTimer = null;
  }
  
  // 1. 选择支付方式
  async selectPaymentMethod(paymentType) {
    // paymentType: 'wechat_native' 或 'alipay_page'
    const response = await axios.put(`/api/booking/${this.bookingId}/pay`, {
      paymentMethod: 1,
      paymentType: paymentType
    });
    
    if (response.data.code === 200) {
      const paymentData = response.data.data;
      this.paymentNo = paymentData.paymentNo;
      return paymentData;
    }
    throw new Error('创建支付订单失败');
  }
  
  // 2. 显示二维码
  showQRCode(qrCodeUrl, elementId) {
    new QRCode(document.getElementById(elementId), {
      text: qrCodeUrl,
      width: 200,
      height: 200
    });
  }
  
  // 3. 开始轮询
  startPolling(onSuccess, onFail) {
    this.pollTimer = setInterval(async () => {
      const response = await axios.get(`/api/payment/query/${this.paymentNo}`);
      
      if (response.data.code === 200) {
        const status = response.data.data.status;
        
        if (status === 2) {
          // 支付成功
          this.stopPolling();
          onSuccess();
        } else if (status === 3) {
          // 支付失败
          this.stopPolling();
          onFail();
        }
      }
    }, 2000);
    
    // 30分钟后自动停止
    setTimeout(() => this.stopPolling(), 30 * 60 * 1000);
  }
  
  // 4. 停止轮询
  stopPolling() {
    if (this.pollTimer) {
      clearInterval(this.pollTimer);
      this.pollTimer = null;
    }
  }
  
  // 5. 模拟扫码（测试环境）
  async mockScan() {
    const response = await axios.post(`/api/mock/payment/scan-success/${this.paymentNo}`);
    return response.data.code === 200;
  }
}

// 使用示例
const payment = new PaymentFlow(13, 300);

// 选择微信支付
const paymentData = await payment.selectPaymentMethod('wechat_native');

// 显示二维码
payment.showQRCode(paymentData.qrCodeUrl, 'qrcode-container');

// 开始轮询
payment.startPolling(
  () => {
    console.log('支付成功！');
    router.push('/payment/success');
  },
  () => {
    console.log('支付失败！');
  }
);

// 测试环境：模拟扫码
if (process.env.NODE_ENV === 'development') {
  setTimeout(() => {
    payment.mockScan();
  }, 3000); // 3秒后自动模拟扫码
}
```

---

## 🔒 生产环境迁移

当需要使用真实支付时，只需：

### 1. 配置支付参数
更新数据库 `payment_config` 表

### 2. 启用真实支付
修改 `application.yml`：
```yaml
alipay:
  enabled: true
wechat:
  pay:
    enabled: true
```

### 3. 移除模拟接口
注释或删除 `MockPaymentController`

### 4. 前端移除模拟按钮
去掉"模拟扫码成功"按钮，只保留轮询逻辑

---

## 📊 数据流转

```
数据库表关系：
booking (预订订单)
  ↓ business_no
payment_order (支付订单)
  ↓ callback
payment_notify_log (支付通知日志)
  ↓ update
booking (状态更新为已支付)
```

---

## ❓ 常见问题

### Q1: 为什么需要轮询？
**A**: 因为支付是异步的，用户扫码后，第三方平台会回调我们的服务器。前端通过轮询来检测支付状态的变化。

### Q2: 轮询间隔多久合适？
**A**: 建议2-3秒一次，既不会给服务器太大压力，用户体验也好。

### Q3: 模拟扫码后多久能检测到？
**A**: 立即！模拟接口会同步处理支付回调，下一次轮询就能检测到状态变化。

### Q4: 二维码过期了怎么办？
**A**: 支付订单有30分钟有效期，过期后需要重新创建预订订单并支付。

### Q5: 可以同时支持微信和支付宝吗？
**A**: 可以！前端提供选择界面，用户选择后传入不同的 `paymentType` 即可。

---

## 🎉 总结

现在你已经有了一个**完整的模拟支付系统**，包括：
- ✅ 支付方式选择（微信/支付宝）
- ✅ 二维码生成和展示
- ✅ 支付状态轮询
- ✅ 模拟扫码成功接口
- ✅ 自动更新订单状态

**无需真实支付配置，即可完整测试支付流程！**

---

**文档版本**: v1.0.0  
**更新时间**: 2025-10-18  
**适用环境**: 开发、测试、演示

