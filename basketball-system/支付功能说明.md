# 篮球场地管理系统 - 支付功能说明

## 📋 支付方式概览

系统支持 **4 种支付方式**：

| 支付方式 | 代码 | 流程类型 | 状态 |
|---------|------|---------|------|
| 在线支付（微信/支付宝） | `paymentMethod = 1` | 异步 | ✅ 已实现（模拟） |
| 余额支付 | `paymentMethod = 2` | 同步 | ✅ 已实现 |
| 会员卡支付 | `paymentMethod = 3` | 同步 | ⚠️ 待实现 |
| 现场支付 | `paymentMethod = 4` | 手动 | ✅ 已实现 |

---

## 🔄 支付流程详解

### 1️⃣ 在线支付（微信/支付宝）

#### 特点
- ✅ 支持微信扫码、微信H5、支付宝PC、支付宝WAP
- ✅ 异步回调机制
- ✅ 返回二维码或跳转URL
- ⚠️ 当前为模拟实现，未集成真实SDK

#### 流程图
```
1. 用户创建预订订单（状态：待支付）
   ↓
2. 用户选择在线支付
   ↓
3. 系统调用 paymentService.createPayment()
   - 创建支付订单
   - 生成支付二维码URL/跳转URL
   ↓
4. 返回支付信息给前端
   {
     "paymentNo": "PAY202510170001",
     "qrCodeUrl": "https://...",
     "expireTime": "2025-10-17 12:30:00"
   }
   ↓
5. 前端展示二维码或跳转支付页面
   ↓
6. 用户完成支付
   ↓
7. 第三方平台回调 /api/payment/callback/{paymentType}
   ↓
8. 系统更新订单状态为"已支付"
   ↓
9. 发送支付成功通知
```

#### 代码示例

**Controller 调用**
```java
@PutMapping("/{id}/pay")
public Result<PaymentResultVO> payBooking(@PathVariable Long id,
                                          @Valid @RequestBody BookingPayDTO payDTO) {
    PaymentResultVO paymentResult = bookingService.payBooking(id, payDTO);
    return Result.success(paymentResult);
}
```

**Service 实现**
```java
if (payDTO.getPaymentMethod() == 1) {
    // 构建支付请求
    PaymentCreateDTO paymentCreateDTO = new PaymentCreateDTO();
    paymentCreateDTO.setBusinessNo(booking.getBookingNo());
    paymentCreateDTO.setBusinessType("booking");
    paymentCreateDTO.setAmount(booking.getActualPrice());
    paymentCreateDTO.setPaymentType("wechat_native"); // 微信扫码
    
    // 调用支付服务
    paymentResult = paymentService.createPayment(booking.getUserId(), paymentCreateDTO);
    
    // 订单保持"待支付"状态，等待回调
    booking.setPaymentMethod(1);
}
```

**前端对接**
```javascript
// 调用支付接口
const response = await axios.put(`/api/booking/${bookingId}/pay`, {
    paymentMethod: 1
});

if (response.data.data) {
    const payment = response.data.data;
    
    // 显示二维码
    showQRCode(payment.qrCodeUrl);
    
    // 轮询查询支付状态
    const timer = setInterval(async () => {
        const status = await queryPaymentStatus(payment.paymentNo);
        if (status === 2) { // 支付成功
            clearInterval(timer);
            alert('支付成功！');
        }
    }, 3000);
}
```

#### ⚠️ 重要提示

**当前实现是模拟的**，生产环境需要：

1. 在 `application.yml` 中配置支付参数：
```yaml
# 微信支付配置
wechat:
  pay:
    enabled: true
    app-id: wx1234567890
    mch-id: 1234567890
    api-v3-key: your-api-v3-key
    merchant-serial-number: your-serial-number
    private-key-path: /path/to/private_key.pem

# 支付宝配置
alipay:
  enabled: true
  app-id: 2021001234567890
  private-key: your-private-key
  alipay-public-key: your-alipay-public-key
  gateway-url: https://openapi.alipay.com/gateway.do
```

2. 修改 `PaymentServiceImpl.createPayment()` 调用真实SDK：
```java
// 微信支付
if (createDTO.getPaymentType().startsWith("wechat_")) {
    return wechatPayService.createNativePay(userId, createDTO);
}
// 支付宝
else if (createDTO.getPaymentType().startsWith("alipay_")) {
    return alipayService.createPagePay(userId, createDTO);
}
```

3. 实现真实的回调验签：
```java
public String handleCallback(String paymentType, Map<String, String> callbackData) {
    // 微信支付验签
    if (paymentType.startsWith("wechat")) {
        if (!wechatPayService.verifySignature(callbackData)) {
            throw new BusinessException("签名验证失败");
        }
    }
    // 支付宝验签
    else if (paymentType.startsWith("alipay")) {
        if (!alipayService.verifySignature(callbackData)) {
            throw new BusinessException("签名验证失败");
        }
    }
    
    // 更新订单状态...
}
```

---

### 2️⃣ 余额支付

#### 特点
- ✅ 同步处理，立即完成
- ✅ 直接扣除用户余额
- ✅ 无需第三方接口

#### 流程图
```
1. 用户选择余额支付
   ↓
2. 检查用户余额是否充足
   ↓
3. 扣除用户余额
   ↓
4. 更新订单状态为"已支付"
   ↓
5. 返回成功（无需返回支付信息）
```

#### 代码实现
```java
else if (payDTO.getPaymentMethod() == 2) {
    // 余额支付 - 直接扣款
    if (user.getBalance().compareTo(booking.getActualPrice()) < 0) {
        throw new BusinessException("余额不足");
    }
    user.setBalance(user.getBalance().subtract(booking.getActualPrice()));
    userMapper.updateById(user);
    
    booking.setPaymentMethod(2);
    booking.setStatus(1); // 已支付
    booking.setPayTime(LocalDateTime.now());
    log.info("余额支付成功: userId={}, amount={}", booking.getUserId(), booking.getActualPrice());
}
```

---

### 3️⃣ 会员卡支付

#### 特点
- ⚠️ 当前为测试模式
- 📝 需要实现会员等级折扣逻辑

#### TODO 实现建议
```java
else if (payDTO.getPaymentMethod() == 3) {
    // 查询用户会员卡信息
    MemberCard memberCard = memberCardService.getUserActiveMemberCard(booking.getUserId());
    
    if (memberCard == null || !memberCard.isValid()) {
        throw new BusinessException("您没有有效的会员卡");
    }
    
    // 根据会员等级计算折扣
    BigDecimal discount = memberCardService.getDiscount(memberCard.getLevel());
    BigDecimal finalAmount = booking.getActualPrice().multiply(discount);
    
    // 扣除会员卡次数或金额
    memberCardService.deduct(memberCard.getId(), booking);
    
    booking.setPaymentMethod(3);
    booking.setStatus(1);
    booking.setPayTime(LocalDateTime.now());
}
```

---

### 4️⃣ 现场支付

#### 特点
- ✅ 用户到场后付款
- ✅ 需要管理员确认
- ✅ 订单先保持"待支付"状态

#### 流程图
```
1. 用户选择现场支付
   ↓
2. 订单状态保持"待支付"
   ↓
3. 用户到现场
   ↓
4. 管理员确认收款
   ↓
5. 管理员调用 updateBookingStatus() 更新为"已支付"
```

#### 代码实现
```java
else if (payDTO.getPaymentMethod() == 4) {
    // 现场支付 - 只更新支付方式，不修改状态
    booking.setPaymentMethod(4);
    log.info("现场支付订单确认成功，等待现场付款: bookingNo={}", booking.getBookingNo());
}
```

#### 管理员确认支付
```bash
PUT /api/admin/booking/{id}/status
{
  "status": 1  # 已支付
}
```

---

## 💾 数据库设计

### 支付订单表（payment_order）

存储所有在线支付的订单信息：

```sql
CREATE TABLE payment_order (
    id BIGINT PRIMARY KEY,
    payment_no VARCHAR(64) UNIQUE COMMENT '支付订单号',
    business_no VARCHAR(64) COMMENT '业务订单号（如预订单号）',
    business_type VARCHAR(32) COMMENT '业务类型（booking/member_card/course）',
    user_id BIGINT COMMENT '用户ID',
    payment_type VARCHAR(32) COMMENT '支付方式（wechat_native/alipay_pc等）',
    amount DECIMAL(10,2) COMMENT '订单金额',
    actual_amount DECIMAL(10,2) COMMENT '实际支付金额',
    fee_amount DECIMAL(10,2) COMMENT '手续费',
    status INT COMMENT '状态：0-待支付, 1-支付中, 2-支付成功, 3-支付失败, 4-已取消, 5-已退款',
    qr_code_url VARCHAR(512) COMMENT '二维码URL',
    payment_url VARCHAR(512) COMMENT '支付跳转URL',
    third_party_order_no VARCHAR(128) COMMENT '第三方订单号',
    third_party_trade_no VARCHAR(128) COMMENT '第三方交易流水号',
    expire_time DATETIME COMMENT '过期时间',
    paid_time DATETIME COMMENT '支付完成时间',
    create_time DATETIME,
    update_time DATETIME
);
```

### 支付配置表（payment_config）

配置支持的支付方式：

```sql
CREATE TABLE payment_config (
    id BIGINT PRIMARY KEY,
    payment_type VARCHAR(32) UNIQUE COMMENT '支付方式',
    payment_name VARCHAR(64) COMMENT '支付方式名称',
    enabled TINYINT COMMENT '是否启用：0-否，1-是',
    fee_rate DECIMAL(10,4) COMMENT '手续费率',
    min_amount DECIMAL(10,2) COMMENT '最小支付金额',
    max_amount DECIMAL(10,2) COMMENT '最大支付金额',
    sort_order INT COMMENT '排序',
    create_time DATETIME,
    update_time DATETIME
);
```

---

## 🧪 测试指南

### 测试场景 1：在线支付（微信扫码）

```bash
# 1. 创建预订
POST /api/booking
{
  "venueId": 1,
  "bookingDate": "2025-10-18",
  "startTime": "10:00",
  "endTime": "12:00"
}
# 返回 bookingId: 123

# 2. 选择在线支付
PUT /api/booking/123/pay
{
  "paymentMethod": 1
}
# 返回：
{
  "code": 200,
  "data": {
    "paymentNo": "PAY202510170001",
    "qrCodeUrl": "https://api.mch.weixin.qq.com/pay/qrcode?data=mock_PAY202510170001",
    "expireTime": "2025-10-17 12:30:00"
  }
}

# 3. 查询支付状态
GET /api/payment/query?paymentNo=PAY202510170001

# 4. 模拟支付回调（测试环境）
POST /api/payment/callback/wechat_native
{
  "out_trade_no": "PAY202510170001",
  "transaction_id": "WX1234567890",
  "trade_state": "SUCCESS"
}
```

### 测试场景 2：余额支付

```bash
# 1. 确认用户余额
GET /api/user/profile
# balance: 500.00

# 2. 创建预订（金额100.00）
POST /api/booking
{...}
# bookingId: 124

# 3. 余额支付
PUT /api/booking/124/pay
{
  "paymentMethod": 2
}
# 返回：
{
  "code": 200,
  "data": null  # 余额支付直接完成，无需返回支付信息
}

# 4. 确认余额已扣除
GET /api/user/profile
# balance: 400.00 (500 - 100)
```

### 测试场景 3：现场支付

```bash
# 1. 创建预订
POST /api/booking
{...}
# bookingId: 125

# 2. 选择现场支付
PUT /api/booking/125/pay
{
  "paymentMethod": 4
}
# 订单状态仍然是"待支付"

# 3. 管理员确认收款
PUT /api/admin/booking/125/status
{
  "status": 1  # 已支付
}
```

---

## 🚀 部署清单

### 开发/测试环境
- ✅ 使用模拟支付（当前实现）
- ✅ `alipay.enabled=false`
- ✅ `wechat.pay.enabled=false`

### 生产环境
- ❌ **禁止使用模拟支付**
- ✅ 配置真实的微信/支付宝参数
- ✅ 集成真实的支付SDK
- ✅ 实现签名验证
- ✅ 配置回调URL
- ✅ 配置支付证书

---

## 📞 常见问题

### Q1: 为什么在线支付直接成功了？
**A**: 当前是模拟实现。真实环境需要：
1. 配置支付参数
2. 集成支付SDK
3. 实现回调验证

### Q2: 如何切换支付方式？
**A**: 前端调用支付接口时传入不同的 `paymentMethod`：
- 1 = 在线支付（微信/支付宝）
- 2 = 余额支付
- 3 = 会员卡支付
- 4 = 现场支付

### Q3: 支付失败后如何处理？
**A**: 系统会：
1. 更新支付订单状态为"支付失败"
2. 保留预订订单为"待支付"状态
3. 用户可以重新发起支付

### Q4: 支付超时怎么办？
**A**: 
- 支付订单30分钟后自动过期
- 预订订单15分钟后自动取消（可配置）
- 用户需要重新创建预订

---

## 📝 开发建议

1. **优先实现余额支付**：最简单，可以快速上线
2. **在线支付分阶段实现**：
   - 第一阶段：模拟支付（当前状态）
   - 第二阶段：集成沙箱环境
   - 第三阶段：接入生产环境
3. **会员卡支付**：根据业务需求决定是否实现
4. **现场支付**：适合线下场馆，需要管理员配合

---

## 📄 相关文档

- [支付流程修复说明.md](./支付流程修复说明.md) - 详细的修复过程
- [JWT认证使用说明.md](./JWT认证使用说明.md) - 用户认证机制
- [数据库字段匹配修复报告.md](./数据库字段匹配修复报告.md) - 数据库修复记录

---

**最后更新**: 2025-10-17
**版本**: v1.0.0

