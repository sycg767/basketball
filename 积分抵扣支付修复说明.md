# 积分抵扣支付修复说明

## 问题描述

用户在预订场地时选择使用积分抵扣，但跳转到支付页面后，积分抵扣信息丢失，仍然显示原价。

## 问题原因

1. **预订创建时未传递积分参数**：在 `Create.vue` 中，用户选择了积分抵扣，但提交预订时没有将 `pointsToUse` 参数传递给后续页面
2. **支付时未使用积分参数**：在 `Detail.vue` 中，支付接口调用时没有传递 `pointsToUse` 参数给后端

## 修复方案

### 1. 预订创建页面 (Create.vue)

**修改位置**：`basketball-web/src/views/booking/Create.vue:436-458`

**修改内容**：
- 在预订成功后跳转到详情页时，通过路由 query 参数传递 `pointsToUse`
- 只有当用户选择使用积分且积分大于0时才传递

```javascript
// 修改前
router.push(`/booking/detail/${res.data}`);

// 修改后
const query = {};
if (usePoints.value && pointsToUse.value > 0) {
  query.pointsToUse = pointsToUse.value;
}
router.push({
  path: `/booking/detail/${res.data}`,
  query
});
```

### 2. 预订详情页面 (Detail.vue)

#### 2.1 接收积分参数

**修改位置**：`basketball-web/src/views/booking/Detail.vue:428-444`

**修改内容**：
- 从路由 query 参数中获取 `pointsToUse`
- 添加计算最终支付金额的函数（扣除积分抵扣）

```javascript
// 积分抵扣（从路由参数获取）
const pointsToUse = ref(parseInt(route.query.pointsToUse) || 0);

// 计算最终支付金额（扣除积分抵扣）
const calculateFinalAmount = () => {
  const actualPrice = bookingDetail.value.actualPrice || bookingDetail.value.totalPrice || 0;
  if (pointsToUse.value > 0) {
    const pointsDeduct = pointsToUse.value / 100;
    const maxDeduct = actualPrice * 0.5; // 最多抵扣50%
    const actualDeduct = Math.min(pointsDeduct, maxDeduct);
    return Math.max(0, actualPrice - actualDeduct).toFixed(2);
  }
  return actualPrice.toFixed(2);
};
```

#### 2.2 支付时传递积分参数

**修改位置1**：`basketball-web/src/views/booking/Detail.vue:675-690`（生成二维码）

```javascript
const payData = {
  paymentMethod: payForm.paymentMethod,
  paymentType: payForm.paymentType
};

// 如果使用积分抵扣，添加积分参数
if (pointsToUse.value > 0) {
  payData.pointsToUse = pointsToUse.value;
}

// 如果是会员卡支付，添加cardId
if (payForm.paymentMethod === 3) {
  if (!selectedCardId.value) {
    ElMessage.warning('请选择会员卡');
    refreshing.value = false;
    return;
  }
  payData.cardId = selectedCardId.value;
}

const res = await payBooking(bookingDetail.value.id, payData);
```

**修改位置2**：`basketball-web/src/views/booking/Detail.vue:787-797`（确认支付）

```javascript
const payData = {
  paymentMethod: payForm.paymentMethod
};

// 如果使用积分抵扣，添加积分参数
if (pointsToUse.value > 0) {
  payData.pointsToUse = pointsToUse.value;
}

// 如果是会员卡支付，添加cardId
if (payForm.paymentMethod === 3) {
  payData.cardId = selectedCardId.value;
}

await payBooking(bookingDetail.value.id, payData);
```

#### 2.3 显示积分抵扣信息

**修改位置**：`basketball-web/src/views/booking/Detail.vue:74-94`

**修改内容**：
- 在费用信息中添加"积分抵扣"项
- 显示使用的积分数量和对应的金额
- 更新实付金额为扣除积分后的金额

```html
<el-descriptions :column="2" border>
  <el-descriptions-item label="单价">
    ¥{{ bookingDetail.price?.toFixed(2) }}/小时
  </el-descriptions-item>
  <el-descriptions-item label="总价">
    ¥{{ bookingDetail.totalPrice?.toFixed(2) }}
  </el-descriptions-item>
  <el-descriptions-item label="优惠金额">
    ¥{{ bookingDetail.discountAmount?.toFixed(2) || '0.00' }}
  </el-descriptions-item>
  <!-- 新增：积分抵扣显示 -->
  <el-descriptions-item label="积分抵扣" v-if="pointsToUse > 0">
    <span class="points-deduct">{{ pointsToUse }}积分 (¥{{ (pointsToUse / 100).toFixed(2) }})</span>
  </el-descriptions-item>
  <el-descriptions-item label="实付金额">
    <!-- 修改：使用计算后的最终金额 -->
    <span class="price-highlight">¥{{ calculateFinalAmount() }}</span>
  </el-descriptions-item>
  <el-descriptions-item label="支付方式" v-if="bookingDetail.payMethodName">
    {{ bookingDetail.payMethodName }}
  </el-descriptions-item>
</el-descriptions>
```

#### 2.4 添加样式

**修改位置**：`basketball-web/src/views/booking/Detail.vue:911-914`

```css
.points-deduct {
  color: #67c23a;
  font-weight: 600;
}
```

## 修改文件清单

### 前端修改 (2个文件)

1. **basketball-web/src/views/booking/Create.vue**
   - 修改预订提交逻辑，传递积分参数到详情页

2. **basketball-web/src/views/booking/Detail.vue**
   - 接收并保存积分参数
   - 添加计算最终支付金额的函数
   - 在两处支付调用中传递积分参数
   - 在费用信息中显示积分抵扣
   - 添加积分抵扣的样式

## 数据流程

```
1. 用户在预订创建页面选择积分抵扣
   ↓
2. 提交预订，携带 pointsToUse 参数跳转到详情页
   ↓
3. 详情页从路由参数获取 pointsToUse
   ↓
4. 显示积分抵扣信息和扣除后的实付金额
   ↓
5. 用户点击支付，将 pointsToUse 传递给后端
   ↓
6. 后端处理积分抵扣并完成支付
```

## 积分抵扣规则

- **兑换比例**：100积分 = 1元
- **最低使用**：100积分起用
- **最高抵扣**：订单金额的50%
- **抵扣计算**：实付金额 = 订单金额 - min(积分金额, 订单金额 × 50%)

## 测试验证

### 测试场景

1. **不使用积分**
   - 预订时不勾选积分抵扣
   - 详情页不显示积分抵扣信息
   - 实付金额 = 订单金额

2. **使用积分（正常情况）**
   - 预订时选择使用500积分
   - 详情页显示"积分抵扣: 500积分 (¥5.00)"
   - 实付金额 = 订单金额 - 5元

3. **使用积分（超过50%限制）**
   - 订单金额10元，选择使用1000积分
   - 实际只能抵扣5元（50%）
   - 实付金额 = 5元

### 验证步骤

```bash
# 1. 启动前端服务
cd basketball-web
npm run dev

# 2. 测试流程
- 登录系统
- 进入场地预订页面
- 选择时间段，勾选"使用积分抵扣"
- 调整积分滑块
- 提交预订
- 检查详情页是否显示积分抵扣信息
- 检查实付金额是否正确
- 完成支付
- 验证积分是否正确扣除
```

## 影响范围

### 功能影响
- ✅ 预订创建流程
- ✅ 预订详情显示
- ✅ 支付流程
- ✅ 积分抵扣计算

### 不影响的功能
- ❌ 其他支付方式（会员卡、余额等）
- ❌ 订单列表
- ❌ 积分记录
- ❌ 其他业务流程

## 注意事项

1. **积分参数传递**：通过路由 query 参数传递，刷新页面后会丢失，但这是合理的，因为用户可以重新选择
2. **后端验证**：后端需要验证积分是否足够，以及抵扣金额是否合法
3. **并发问题**：后端需要处理积分扣除的并发问题，避免超扣
4. **用户体验**：在详情页明确显示积分抵扣信息，让用户清楚知道使用了多少积分

## 总结

本次修复解决了积分抵扣信息在页面跳转时丢失的问题，确保：
1. 用户选择的积分抵扣信息能正确传递到支付页面
2. 支付时能正确使用积分抵扣
3. 用户能清楚看到积分抵扣的详细信息
4. 实付金额正确计算并显示

修复后的系统能够完整支持积分抵扣功能，提升用户体验。
